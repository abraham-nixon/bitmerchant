import binascii
from unittest import TestCase

import base58

from bitmerchant.wallet.network import BitcoinTestNet
from bitmerchant.wallet.keys import ChecksumException
from bitmerchant.wallet.keys import IncompatibleNetworkException
from bitmerchant.wallet.keys import KeyParseError  # TODO test this
from bitmerchant.wallet.keys import PrivateKey
from bitmerchant.wallet.keys import ExtendedPrivateKey
from bitmerchant.wallet.keys import PublicKey


class _TestPrivateKeyBase(TestCase):
    def setUp(self):
        # This private key chosen from the bitcoin docs:
        # https://en.bitcoin.it/wiki/Wallet_import_format
        self.expected_key = \
            "0C28FCA386C7A227600B2FE50B7CAE11EC86D3BF1FBE471BE89827E19D72AA1D"
        self.key = PrivateKey(long(self.expected_key, 16))


class _TestPublicKeyBase(TestCase):
    def setUp(self):
        # This private key chosen from the bitcoin docs:
        # https://en.bitcoin.it/wiki/Wallet_import_format
        self.expected_private_key = \
            "18E14A7B6A307F426A94F8114701E7C8E774E7F9A47E2C2035DB29A206321725"
        self.private_key = PrivateKey(long(self.expected_private_key, 16))
        self.public_key = PublicKey.from_hex_key(
            "04"
            "50863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B2352"
            "2CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6")


class TestPrivateKey(_TestPrivateKeyBase):
    def test_raw_key_hex(self):
        exp = self.key.private_exponent
        self.assertEqual(PrivateKey(exp), self.key)

    def test_raw_key_hex_bytes(self):
        key = binascii.unhexlify(self.key.key)
        self.assertEqual(PrivateKey.from_hex_key(key), self.key)

    def test_from_master_password(self):
        password = "correct horse battery staple"
        expected_wif = "5KJvsngHeMpm884wtkJNzQGaCErckhHJBGFsvd3VyK5qMZXj3hS"
        expected_pub_address = "1JwSSubhmg6iPtRjtyqhUYYH7bZg3Lfy1T"

        key = PrivateKey.from_master_password(password)
        self.assertEqual(key.export_to_wif(), expected_wif)
        self.assertEqual(
            key.get_public_key().to_address(), expected_pub_address)


class TestWIF(_TestPrivateKeyBase):
    def setUp(self):
        super(TestWIF, self).setUp()
        self.expected_wif = \
            '5HueCGU8rMjxEXxiPuD5BDku4MkFqeZyd4dZ1jvhTVqvbTLvyTJ'

    def test_export_to_wif(self):
        self.assertEqual(
            self.key.export_to_wif(),
            self.expected_wif)

    def test_import_wif(self):
        key = PrivateKey.from_wif(self.expected_wif)
        self.assertEqual(key, self.key)

    def test_import_wif_invalid_network(self):
        self.assertRaises(
            IncompatibleNetworkException, PrivateKey.from_wif,
            self.key.export_to_wif(), BitcoinTestNet)

    def test_import_wif_network(self):
        # Make a wif for bitcoin testnet:
        testnet_key = PrivateKey(
            self.key.private_exponent, network=BitcoinTestNet)
        testnet_wif = testnet_key.export_to_wif()
        # We should be able to load it properly
        key = PrivateKey.from_wif(testnet_wif, BitcoinTestNet)
        self.assertEqual(testnet_key, key)

    def test_bad_checksum(self):
        wif = self.key.export_to_wif()
        bad_checksum = base58.b58encode(binascii.unhexlify('FFFFFFFF'))
        wif = wif[:-8] + bad_checksum
        self.assertRaises(ChecksumException, PrivateKey.from_wif, wif)


class TestPublicKey(_TestPublicKeyBase):
    def test_leading_zeros(self):
        # This zero-leading x coordinate generated by:
        # pvk = '18E14A7B6A307F426A94F8114701E7C8E774E7F9A47E2C2035DB29A206321725'  # nopep8
        # pubkey = Public_key(SECP256k1.generator, SECP256k1.generator * long(pvk, 16))  # nopep8
        # for i in range(1, 10000):
        # x = (pubkey.point * i).x()
        # k = keys.long_to_hex(x, 64)
        # if k.startswith('0'):
        #     print i
        #     break
        expected_key = (
            "04"
            "02CBFD5410FD04973C096A4275BF75070955EBD689F316A6FBD449980BA7B756"
            "C559764E5C367C03E002751AAF4EF8EC40FE97CDA9B2D3F14FDD4CD244E8FCD2")
        public_key = PublicKey.from_hex_key(expected_key)
        self.assertEqual(public_key.key, expected_key)

    def test_address(self):
        expected_address = "16UwLL9Risc3QfPqBUvKofHmBQ7wMtjvM"
        actual_address = self.public_key.to_address()
        self.assertEqual(expected_address, actual_address)

    def test_private_to_public(self):
        self.assertEqual(
            self.private_key.get_public_key(),
            self.public_key)

    def test_unhexlified_key(self):
        key_bytes = binascii.unhexlify(self.public_key.key)
        self.assertEqual(
            PublicKey.from_hex_key(key_bytes),
            self.public_key)

    def test_bad_key(self):
        self.assertRaises(KeyParseError, PublicKey.from_hex_key, 'badkey')

    def test_bad_network_key(self):
        key = self.public_key.key
        # Change the network constant
        key = "00" + key[2:]
        self.assertRaises(IncompatibleNetworkException,
                          PublicKey.from_hex_key, key)


class TestExtendedPrivateKey(TestCase):
    def setUp(self):
        self.expected_key = (
            "0488ADE4"  # BitcoinMainNet version
            "00"  # depth
            "00000000"  # parent fingerprint
            "00000000"  # child_number
            # chain_code
            "873DFF81C02F525623FD1FE5167EAC3A55A049DE3D314BB42EE227FFED37D508"
            "00"  # key identifier
            # private exponent
            "E8F32E723DECF4051AEFAC8E2C93C9C5B214313817CDB01A1494B917C8436B35")
        self.master_key = ExtendedPrivateKey.from_hex_key(self.expected_key)

    def test_serialize_master_key(self):
        self.assertEqual(self.expected_key, self.master_key.serialize())

    def test_m_0p(self):
        key = (
            "0488ADE4013442193E80000000"
            "47FDACBD0F1097043B78C63C20C34EF4ED9A111D980047AD16282C7AE6236141"
            "00"
            "EDB2E14F9EE77D26DD93B4ECEDE8D16ED408CE149B6CD80B0715A2D911A0AFEA")
        pk = ExtendedPrivateKey.from_hex_key(key)
        self.assertEqual(pk.serialize(), key)
        self.assertEqual(pk.parent_fingerprint, self.master_key.fingerprint)
        self.assertEqual(pk.child_number, 0x80000000)

    def test_m_0p_1(self):
        key = (
            "0488ADE4025C1BD64800000001"
            "2A7857631386BA23DACAC34180DD1983734E444FDBF774041578E9B6ADB37C19"
            "00"
            "3C6CB8D0F6A264C91EA8B5030FADAA8E538B020F0A387421A12DE9319DC93368")
        pk = ExtendedPrivateKey.from_hex_key(key)
        self.assertEqual(pk.serialize(), key)
        self.assertEqual(pk.child_number, 1)

    def test_m_0p_1_2p(self):
        key = (
            "0488ADE403BEF5A2F980000002"
            "04466B9CC8E161E966409CA52986C584F07E9DC81F735DB683C3FF6EC7B1503F"
            "00"
            "CBCE0D719ECF7431D88E6A89FA1483E02E35092AF60C042B1DF2FF59FA424DCA")
        pk = ExtendedPrivateKey.from_hex_key(key)
        self.assertEqual(pk.serialize(), key)
        self.assertEqual(pk.child_number, 0x80000000 + 2)

    def test_invalid_network_prefix(self):
        pass

    def test_invalid_key_data_prefix(self):
        pass

    def test_invalid_fingerprint(self):
        pass

    def test_identifier(self):
        pass

    def test_fingerprint(self):
        pass
